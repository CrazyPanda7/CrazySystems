buildscript {
	repositories {
		jcenter()
		mavenCentral()
		maven {
			name = 'forge'
			url = 'https://files.minecraftforge.net/maven'
		}
		maven {
			name = 'gradle'
			url 'https://plugins.gradle.org/m2/'
		}
	}
	dependencies {
		classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: project.fg_version
	}
}

plugins {
	id 'com.github.spotbugs' version '1.6.9'
	id 'com.matthewprenger.cursegradle' version '1.4.0'
	id 'maven-publish'
	id 'jacoco'
	id 'checkstyle'
}

apply plugin: 'net.minecraftforge.gradle.forge' // FG2.x
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'pmd'

import org.gradle.util.GradleVersion
if (GradleVersion.current() < GradleVersion.version('4.0')) {
	apply plugin: 'findbugs'
}

project.afterEvaluate {
	jacoco {
		toolVersion = '0.8.3'
	}

	project.task(type: JacocoReport, 'junitPlatformJacocoReport',
	{
		if (GradleVersion.current() >= GradleVersion.version('5.0')) {
			getSourceDirectories().from(files('./src/main'))
			getClassDirectories().from(files("${project.buildDir}/classes/main"))
		} else {
			sourceDirectories = files('./src/main')
			classDirectories = files("${project.buildDir}/classes/main")
		}
	})
}


spotbugs {
	ignoreFailures = true
	toolVersion = '3.1.6'
	effort = 'max'
	reportLevel = 'low'
}

tasks.withType(com.github.spotbugs.SpotBugsTask) {
	reports {
		xml.enabled = false
		html.enabled = true
	}
}

checkstyle {
	ignoreFailures = true
	toolVersion = '8.20' // 5.7 is default
	showViolations = false
}

pmd {
	consoleOutput = false
	ignoreFailures = true
	//sourceSets = [sourceSets.main]
	reportsDir = file("$buildDir/reports/pmd")
	rulePriority = 5
	ruleSets = ['java-android', 'java-basic', 'java-braces', 'java-clone', 'java-codesize', 'java-comments', 'java-controversial', 'java-coupling', 'java-design', 'java-empty', 'java-finalizers', 'java-imports', 'java-j2ee', 'java-javabeans', 'java-junit', 'java-logging-jakarta-commons', 'java-logging-java', 'java-migrating', 'java-migrating_to_junit4', 'java-naming', 'java-optimizations', 'java-strictexception', 'java-strings', 'java-sunsecure', 'java-typeresolution', 'java-unnecessary', 'java-unusedcode']
	toolVersion = '5.8.1';
	if (GradleVersion.current() >= GradleVersion.version('5.6')) {
	}
}

tasks.withType(JavaCompile) {
	options.encoding = 'UTF-8'
	options.compilerArgs = ['-Xlint:deprecation', // deprecation, rawtypes, cast, unchecked, all
	]
	compileJava.options.compilerArgs += '-proc:none'
}

tasks.withType(Test) {
	compileTestJava.options.compilerArgs += '-proc:none'
}

test {
	if (GradleVersion.current() >= GradleVersion.version('4.6')) {
		useJUnitPlatform()
	}
}

version = "${version}." + getBuildNumber()
group = "${group}"
archivesBaseName = "${archivesBaseName}"

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8
compileJava.sourceCompatibility = JavaVersion.VERSION_1_8
compileJava.targetCompatibility = JavaVersion.VERSION_1_8

eclipse.project {
	buildCommand 'org.eclipse.buildship.core.gradleprojectbuilder'
	natures 'org.eclipse.buildship.core.gradleprojectnature'
}

idea.module {
	downloadJavadoc = true
	iml {
		whenMerged { module ->
			module.dependencies*.exported = true
		}
	}
}

class Secrets {
	Map m_data = null

	final String getProperty(final String key) {
		return (m_data && (m_data[key] != null)) ? m_data[key] : ''
	}
}

final def secretFile
if (System.getenv('SECRET_FILE')) {
	secretFile = file System.getenv().SECRET_FILE
} else {
	secretFile = file 'secret.json'
}

import groovy.json.JsonSlurper
project.ext.secret = new Secrets()
secretFile.withReader {
	project.secret.m_data = new JsonSlurper().parse it
}


minecraft {
	version = "${forge_mc_version}-${forge_version}"
	mappings = "${mcp_mappings_version}"

	if (project.hasProperty('runDir')) {
		runDir = project.runDir
	} else if (file('../run').exists()) {
		runDir = '../run'
	} else {
		runDir = 'run'
	}

	replace '@MOD_VERSION@', version
	replace '@FINGERPRINT@', project.findProperty('signSHA1')

	makeObfSourceJar = getBooleanProperty('create_source_jar')

	useDepAts = getBooleanProperty('dep_has_ats')
}

String GCBuild = "261"
String GCVersion = "1.12.2-4.0.2.${GCBuild}"

repositories {
	ivy {
		url "https://micdoodle8.com/new-builds/"
		layout 'pattern', {
			artifact "[organization]/${GCBuild}/[module]-[revision].jar"
		}
		metadataSources {
			artifact()
		}
	}
	mavenLocal()
	jcenter()
	mavenCentral()

	maven {
		name 'MMD'
		url 'https://maven.mcmoddev.com/'
	}
	maven {
		name 'MJR'
		url 'https://maven.mjrlegends.com/'
	}
	maven {
		name 'DVS1 Maven FS'
		url 'http://dvs1.progwml6.com/files/maven'
	}
	maven {
		name = 'ReadOnlyDev'
		url = 'https://mvn.romvoid.dev/'
	}
}

dependencies {

	////////////////////////////////
	// NON-MINECRAFT RELATED DEPS //
	////////////////////////////////
	testCompile('org.junit.platform:junit-platform-launcher:1.5.+')
	testCompile('org.junit.jupiter:junit-jupiter-api:5.5.+') // testImplementation
	testRuntime('org.junit.jupiter:junit-jupiter-engine:5.5.+') //testRuntimeOnly
	if (GradleVersion.current() >= GradleVersion.version('2.13')) {
		testCompileOnly 'junit:junit:4.12'
	}
	testRuntime 'org.junit.vintage:junit-vintage-engine:5.5.+' //testRuntimeOnly
	testCompile('org.mockito:mockito-core:2.+')
	testCompile('org.mockito:mockito-junit-jupiter:2.+') {
		exclude group: 'org.junit.jupiter', module: 'junit-jupiter-engine'
	}
	if (GradleVersion.current() >= GradleVersion.version('4.6')) {
		annotationProcessor group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.11.0'
	}

	////////////////////////////////
	//   MINECRAFT RELATED DEPS   //
	////////////////////////////////
	
	compile "GC-1.12-dev:GalacticraftCore-Dev:${GCVersion}"
	compile "GC-1.12-dev:Galacticraft-API:${GCVersion}"
	compile "GC-1.12-dev:Galacticraft-Planets-Dev:${GCVersion}"
	compile "GC-1.12-dev:MicdoodleCore-Dev:${GCVersion}"
	
	compile "mezz.jei:jei_${mc_version}:4.8.5.144:api"
	runtime "mezz.jei:jei_${mc_version}:4.8.5.144"
	
	compile 'net.rom:ReadOnlyCore:1.12.2-1.0.9.0:dev'
}

processResources {
	inputs.property 'version', version
	inputs.property 'mcversion', project.minecraft.version

	from (sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'
		expand 'version': version, 'mcversion': project.minecraft.version
	}

	from (sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}

	rename '(.+_at.cfg)', 'META-INF/$1'
}

apply from: 'gradle/artifacts.gradle'

curseforge {
	if (project.hasProperty('curseforge_project_id')) {
		apiKey = secret.curseforgeAPIKey
		project {
			id = project.curseforge_project_id
			if (project.hasProperty('curseforge_changelog_filename')) {
				changelog = file(project.curseforge_changelog_filename)
			} else {
				changelog = ''
			}
			if (project.hasProperty('curseforge_changelog_type')) {
				changelogType = project.curseforge_changelog_type
			}
			if ((project.hasProperty('curseforge_release_type')) && ((project.curseforge_release_type == 'alpha') || (project.curseforge_release_type == 'beta') || (project.curseforge_release_type == 'release'))) {
				releaseType = project.curseforge_release_type
			} else {
				releaseType = 'alpha'
			}
			if (project.hasProperty('curseforge_versions')) {
				final def versions = "${project.curseforge_versions}".split(', ')
				versions.each {
					addGameVersion "${it}"
				}
			}
			mainArtifact(jar) {
				if (getBooleanProperty('curseforge_use_custom_display_name')) {
					displayName = "${project.name} ${project.display_version}"
				}
				if (project.hasProperty('curseforge_requirements') || project.hasProperty('curseforge_optionals') || project.hasProperty('curseforge_embeddeds') || project.hasProperty('curseforge_tools') || project.hasProperty('curseforge_incompatibles') || project.hasProperty('curseforge_includes')) {
					relations {
						if (project.hasProperty('curseforge_requirements')) {
							final def requirements = "${project.curseforge_requirements}".split(', ')
							requirements.each {
								requiredDependency "${it}"
							}
						}
						if (project.hasProperty('curseforge_optionals')) {
							final def optionals = "${project.curseforge_optionals}".split(', ')
							optionals.each {
								optionalDependency "${it}"
							}
						}
						if (project.hasProperty('curseforge_embeddeds')) {
							final def embeddeds = "${project.curseforge_embeddeds}".split(', ')
							embeddeds.each {
								embeddedLibrary "${it}"
							}
						}
						if (project.hasProperty('curseforge_tools')) {
							final def tools = "${project.curseforge_tools}".split(', ')
							tools.each {
								tool "${it}"
							}
						}
						if (project.hasProperty('curseforge_incompatibles')) {
							final def incompatibles = "${project.curseforge_incompatibles}".split(', ')
							incompatibles.each {
								incompatible "${it}"
							}
						}
						if (project.hasProperty('curseforge_includes')) {
							final def includes = "${project.curseforge_includes}".split(', ')
							includes.each {
								include "${it}"
							}
						}
					}
				}
			}
			if (getBooleanProperty('create_api_jar')) {
				addArtifact(apiJar) {
					if (getBooleanProperty('curseforge_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} API"
					}
				}
			}
			if (getBooleanProperty('create_source_jar')) {
				addArtifact(sourceJar) {
					if (getBooleanProperty('curseforge_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} Sources"
					}
				}
			}
			if (getBooleanProperty('create_deobf_jar')) {
				addArtifact(deobfJar) {
					if (getBooleanProperty('curseforge_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} Development"
					}
				}
			}
			if (getBooleanProperty('create_javadoc_jar')) {
				addArtifact(javadocJar) {
					if (getBooleanProperty('curseforge_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} Javadoc"
					}
				}
			}
		}
	}
}

publishing {
	publications {
		mavenJava(MavenPublication) {
			groupId project.group
			artifactId project.archivesBaseName
			version project.version
			from components.java
			if (getBooleanProperty('create_source_jar')) {
				artifact sourceJar {
					classifier 'sources'
				}
			}
			if (getBooleanProperty('create_api_jar')) {
				artifact apiJar {
					classifier 'api'
				}
			}
			if (getBooleanProperty('create_deobf_jar')) {
				artifact deobfJar {
					classifier 'dev'
				}
			}
			if (getBooleanProperty('create_javadoc_jar')) {
				artifact javadocJar {
					classifier 'javadoc'
				}
			}
		}
	}
	repositories {
		maven {
			url = "file://${local_maven}"
		}
	}
}

boolean getBooleanProperty(final String property) {
	if (project.hasProperty(property)) {
		return ((String) project.findProperty(property)).toBoolean()
	} else {
		return false
	}
}

Object findProperty(final String propertyName) {
	return hasProperty(propertyName) ? property(propertyName) : null;
}

String getBuildNumber() {
	def versionFile = file('version.properties')
	if (versionFile.canRead()) {
		Properties versionProps = new Properties()
		versionProps.load(new FileInputStream(versionFile))
		return versionProps['build_num'].toString()
	}
	return "1"
}

task incrementBuild {
	doFirst {
		def versionFile = file('version.properties')
		if (versionFile.canRead()) {
			Properties versionProps = new Properties()
			versionProps.load(new FileInputStream(versionFile))
			def num = versionProps['build_num'].toInteger() + 1
			println("incrementing BuildNumber to: " + num)
			versionProps['build_num'] = num.toString()
			versionProps.store(versionFile.newWriter(), null)
		} else {
			println("version.properties file not found! Ignoring.")
		}
	}
}

build.finalizedBy incrementBuild // only increment on successful builds
tasks.build.dependsOn signJar
tasks.publish.dependsOn build
tasks.curseforge.dependsOn publish
